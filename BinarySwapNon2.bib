% Encoding: UTF-8

@Article{Molnar1994,
  author  = {Steven Molnar and Michael Cox and David Ellsworth and Henry Fuchs},
  title   = {A Sorting Classification of Parallel Rendering},
  journal = {IEEE Computer Graphics and Applications},
  year    = {1994},
  volume  = {14},
  number  = {4},
  pages   = {23--32},
  month   = {July},
  comment = {The seminal paper on the sorting classification for parallel rendering (sort-first, sort-middle, sort-last).},
}

@Article{Wylie2001,
  author  = {Brian Wylie and Constantine Pavlakos and Vasily Lewis and Kenneth Moreland},
  title   = {Scalable Rendering on {PC} Clusters},
  journal = {IEEE Computer Graphics and Applications},
  year    = {2001},
  volume  = {21},
  number  = {4},
  pages   = {62--70},
  month   = {July/August},
  comment = {Early article demonstrating the good scaling performance of sort-last parallel rendering.  (Does not really compare to other parallel rendering methods, although those are known to scale poorly.  You can use [Mueller1995] to argue poor scaling of sort-first.)},
}

@Article{Childs2010,
  author   = {Hank Childs and David Pugmire and Sean Ahern and Brad Whitlock and Mark Howison and Prabhat and Gunther H. Weber and E. Wes Bethel},
  title    = {Extreme Scaling of Production Visualization Software on Diverse Architectures},
  journal  = {IEEE Computer Graphics and Applications},
  year     = {2010},
  volume   = {30},
  number   = {3},
  pages    = {22--31},
  month    = {May/June},
  abstract = {This article presents the results of experiments studying how the pure-parallelism paradigm scales to massive data sets, including 16,000 or more cores on trillion-cell meshes, the largest data sets published to date in the visualization literature. The findings on scaling characteristics and bottlenecks contribute to understanding how pure parallelism will perform in the future.},
  comment  = {Explores the scaling of visualization pipelines (VisIt specifically) on full petascale machines.},
  doi      = {10.1109/MCG.2010.51},
  url      = {http://dx.doi.org/10.1109/MCG.2010.51},
}

@InProceedings{Moreland2011:SC,
  author    = {Kenneth Moreland and Wesley Kendall and Tom Peterka and Jian Huang},
  title     = {An Image Compositing Solution at Scale},
  booktitle = {Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (SC '11)},
  year      = {2011},
  month     = {November},
  comment   = {A compendium of optimizations for sort-last image-compositing parallel rendering including  Radix-k compositing order, image compression, image interlacing, non-powers-of-two binary swap (telescoping), and improved image collection.  All the techniques are collected in the IceT parallel rendering library and scalability is shown on a petascale machine.},
  doi       = {10.1145/2063384.2063417},
  url       = {http://dx.doi.org/10.1145/2063384.2063417},
}

@InProceedings{Peterka2009:ICPP,
  author    = {Tom Peterka and Hongfeng Yu and Robert Ross and Kwan-Liu Ma and Rob Latham},
  title     = {End-to-End Study of Parallel Volume Rendering on the {IBM Blue Gene/P}},
  booktitle = {Proceedings of ICPP '09},
  year      = {2009},
  pages     = {566--573},
  month     = {September},
  comment   = {Measures very large scale parallel volume rendering.  Shows evidence of I/O dominating visualization/rendering.},
  doi       = {10.1109/ICPP.2009.27},
  url       = {http://dx.doi.org/10.1109/ICPP.2009.27},
}

@InBook{Peterka2013,
  chapter   = {Parallel Image Compositing Methods},
  pages     = {71--89},
  title     = {High Performance Visualization: Enabling Extreme Scale Insight},
  publisher = {CRC Press},
  year      = {2013},
  author    = {Tom Peterka and Kwan-Liu Ma},
  editor    = {E. Wes Bethel and Hank Childs and Charles Hansen},
  isbn      = {978-1-4398-7572-8},
  comment   = {A basic overview of sort-last parallel image compositing methods. Includes discussion of direct-send, tree, binary-swap, 2-3 swap, and radix-k.},
}

@Article{SkyBridge,
  author  = {Neal Singer},
  title   = {Sandia turns on Sky Bridge supercomputer},
  journal = {Sandia Lab News},
  year    = {2014},
  month   = {December 12},
  note    = {\url{http://www.sandia.gov/news/publications/labnews/archive/14-12-12.html#3}},
  comment = {A simple source for the Sky Bridge computer. Not the best publication in the world, but there are few publications on it.},
  url     = {http://www.sandia.gov/news/publications/labnews/archive/14-12-12.html#3},
}

@InProceedings{23Swap,
  author    = {Hongfeng Yu and Chaoli Wang and Kwan-Liu Ma},
  title     = {Massively Parallel Volume Rendering Using 2-3 Swap Image Compositing},
  booktitle = {Proceedings of the 2008 ACM/IEEE Conference on Supercomputing},
  year      = {2008},
  month     = {November},
  comment   = {A varient of binary swap that handles non-powers of two.  Works by allowing groups of either two or three, possibly at the same time.  If both are used, the images are re-partitioned to sixths and redistributed/composited as necessary.},
  doi       = {10.1109/SC.2008.5219060},
}

@InProceedings{Ahrens1998,
  author    = {James Ahrens and James Painter},
  title     = {Efficient Sort-Last Rendering Using Compression-Based Image Compositing},
  booktitle = {Second Eurographics Workshop on Parallel Graphics and Visualization},
  year      = {1998},
  month     = {September},
  comment   = {Early suggestion to use run lengths in image compositing. (There is a reference to an even earlier suggestion.)},
}

@InProceedings{Moreland2001,
  author    = {Kenneth Moreland and Brian Wylie and Constantine Pavlakos},
  title     = {Sort-Last Parallel Rendering for Viewing Extremely Large Data Sets on Tile Displays},
  booktitle = {Proceedings of the IEEE 2001 Symposium on Parallel and Large-Data Visualization and Graphics},
  year      = {2001},
  pages     = {85--92},
  month     = {October},
  comment   = {Initial publication of the tiled display sort-last image compositing algorithms that form the basis for IceT.},
}

@Misc{OpenSWR,
  author       = {Bruce Cherniak},
  title        = {{OpenSWR}: A Scalable High-Performance Software Rasterizer for Scivis},
  howpublished = {Presentation, {\it Intel HPC Developer Conference}},
  month        = nov,
  year         = {1015},
  comment      = {Introduces the OpenSWR parallel rasterizer for rendering.

This is not a great source. It is not a real publication, it is just a presentation. In fact, it is a presentation made by an Intel employee at an event organized by Intel, so don't expect any external peer review here. However, the OpenSWR team does not seem to be interested in publishing, and this is the best that I could find.},
  url          = {http://openswr.org/talks/SC15DevConf-OpenSWR.pdf},
}

@InProceedings{Larsen2015:RayTrace,
  author    = {Matthew Larsen and Jeremy S. Meredith and Paul A. Navratil and Hank Childs},
  title     = {Ray Tracing Within a Data Parallel Framework},
  booktitle = {IEEE Pacific Visualization Symposium (PacificVis)},
  year      = {2015},
  pages     = {279--286},
  month     = {April},
  abstract  = {Current architectural trends on supercomputers have dramatic increases in the number of cores and available computational power per die, but this power is increasingly difficult for programmers to harness effectively. High-level language constructs can simplify programming many-core devices, but this ease comes with a potential loss of processing power, particularly for cross-platform constructs. Recently, scientific visualization packages have embraced language constructs centering around data parallelism, with familiar operators such as map, reduce, gather, and scatter. Complete adoption of data parallelism will require that central visualization algorithms be revisited, and expressed in this new paradigm while preserving both functionality and performance. This investment has a large potential payoff: portable performance in software bases that can span over the many architectures that scientific visualization applications run on. With this work, we present a method for ray tracing consisting of entirely of data parallel primitives. Given the extreme computational power on nodes now prevalent on supercomputers, we believe that ray tracing can supplant rasterization as the work-horse graphics solution for scientific visualization. Our ray tracing method is relatively efficient, and we describe its performance with a series of tests, and also compare to leading-edge ray tracers that are optimized for specific platforms. We find that our data parallel approach leads to results that are acceptable for many scientific visualization use cases, with the key benefit of providing a single code base that can run on many architectures.},
  comment   = {An experiment where a ray tracer was written using a system of data-parallel primitives (specifically in EAVL although later work moved to VTK-m). The EAVL ray tracer was compared with NVIDIA's in-house solution designed specifically for CUDA (OptiX) and the Intel in-house solution for Xeon (Embree). The portable data-parallel primitive implementation got within a factor of two of each.},
  doi       = {10.1109/PACIFICVIS.2015.7156388},
  url       = {http://dx.doi.org/10.1109/PACIFICVIS.2015.7156388},
}

@Article{Moreland2016:VTKm,
  author   = {Kenneth Moreland and Christopher Sewell and William Usher and Li-Ta Lo and Jeremy Meredith and David Pugmire and James Kress and Hendrik Schroots and Kwan-Liu Ma and Hank Childs and Matthew Larsen and Chun-Ming Chen and Robert Maynard and Berk Geveci},
  title    = {{VTK-m}: Accelerating the Visualization Toolkit for Massively Threaded Architectures},
  journal  = {IEEE Computer Graphics and Applications},
  year     = {2016},
  volume   = {36},
  number   = {3},
  pages    = {48--58},
  month    = {May/June},
  abstract = {One of the most critical challenges for high-performance computing (HPC) scientific visualization is execution on massively threaded processors. Of the many fundamental changes we are seeing in HPC systems, one of the most profound is a reliance on new processor types optimized for execution bandwidth over latency hiding. Our current production scientific visualization software is not designed for these new types of architectures. To address this issue, the VTK-m framework serves as a container for algorithms, provides flexible data representation, and simplifies the design of visualization algorithms on new and future computer architecture.},
  comment  = {The first comprehensive publication for VTK-m.},
  doi      = {10.1109/MCG.2016.48},
  url      = {http://dx.doi.org/10.1109/MCG.2016.48},
}

@Article{Wald2014,
  author   = {Ingo Wald and Sven Woop and Carsten Benthin and Gregory S. Johnson and Manfred Ernst},
  title    = {Embree: A Kernel Framework for Efficient {CPU} Ray Tracing},
  journal  = {ACM Transactions on Graphics (TOG)},
  year     = {2014},
  volume   = {33},
  number   = {4},
  month    = jul,
  abstract = {We describe Embree, an open source ray tracing framework for x86 CPUs. Embree is explicitly designed to achieve high performance in professional rendering environments in which complex geometry and incoherent ray distributions are common. Embree consists of a set of low-level kernels that maximize utilization of modern CPU architectures, and an API which enables these kernels to be used in existing renderers with minimal programmer effort. In this paper, we describe the design goals and software architecture of Embree, and show that for secondary rays in particular, the performance of Embree is competitive with (and often higher than) existing state-of-the-art methods on CPUs and GPUs.},
  comment  = {The paper to use to reference Intel's Embree ray casting software. Probably also the best reference for OSPRay (or at least the performance of it). Although OSPRay is never mentioned in the paper, Embree is the underlying ray casting engine for OSPRay.},
  doi      = {10.1145/2601097.2601199},
}

@Article{Knoll2014,
  author   = {Aaron Knoll and Ingo Wald and Paul Navratil and Anne Bowen and Khairi Reda and Michael E. Papka and Kelly Gaither},
  title    = {{RBF} Volume Ray Casting on Multicore and Manycore {CPUs}},
  journal  = {Computer Graphics Forum (Proceedings of EuroVis)},
  year     = {2014},
  volume   = {33},
  number   = {3},
  pages    = {71--80},
  month    = jun,
  abstract = {Modern supercomputers enable increasingly large N‐body simulations using unstructured point data. The structures implied by these points can be reconstructed implicitly. Direct volume rendering of radial basis function (RBF) kernels in domain‐space offers flexible classification and robust feature reconstruction, but achieving performant RBF volume rendering remains a challenge for existing methods on both CPUs and accelerators. In this paper, we present a fast CPU method for direct volume rendering of particle data with RBF kernels. We propose a novel two‐pass algorithm: first sampling the RBF field using coherent bounding hierarchy traversal, then subsequently integrating samples along ray segments. Our approach performs interactively for a range of data sets from molecular dynamics and astrophysics up to 82 million particles. It does not rely on level of detail or subsampling, and offers better reconstruction quality than structured volume rendering of the same data, exhibiting comparable performance and requiring no additional preprocessing or memory footprint other than the BVH. Lastly, our technique enables multi‐field, multi‐material classification of particle data, providing better insight and analysis. },
  comment  = {Documents the high performance volume rendering work lead by Aaron Knoll.},
  doi      = {https://doi.org/10.1111/cgf.12363},
}

@InProceedings{BinarySwap1,
  author    = {Kwan-Liu Ma and James S. Painter and Charles D. Hansen and Michael F. Krogh},
  title     = {A Data Distributed, Parallel Algorithm for Ray-Traced Volume Rendering},
  booktitle = {Proceedings of the 1993 Symposium on Parallel Rendering},
  year      = {1993},
  pages     = {15--22},
  comment   = {One of the original binary-swap papers.},
  doi       = {10.1145/166181.166183},
  url       = {http://dx.doi.org/10.1145/166181.166183},
}

@Comment{jabref-meta: databaseType:bibtex;}
